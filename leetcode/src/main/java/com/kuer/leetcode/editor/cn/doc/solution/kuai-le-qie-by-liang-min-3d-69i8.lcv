### 解题思路

- **题目重解读**：
  我有`n`个左括号和`n`个右括号，目标是得到所有可行的括号组合。

- **暴力想法**：
  无非就是一个`2n`长度的字符串，对于字符串的每个位置`i`，只能在`（`或`）`中选择其一来填写，直接枚举出所有的字符串状态，再判断是否是合法的括号对，是就加入答案，不是就排除。

- **dfs想法**：
  在暴力的想法上，加上剪枝的思路。对于位置`i`，`s`为`0`到`i-1`位置生成的字符串，同时记录待匹配的`(`个数`p`和剩余未选择的括号对个数`n`，dfs的规则如下：

1. `p==0 and n==0`: 左括号`(`匹配完毕，没有剩余的括号对可以选择，将`s`加入答案
2. `p==0 and n!=0`: 左括号`(`匹配完毕，剩余`n`个括号对可以选择，继续生成字符串，但位置`i`只能选择`(`,还剩余`n-1`个括号对可以选择，继续dfs
3. `p!=0 and n==0`: 剩余`p`个左括号`(`待匹配，没有剩余的括号对可以选择，则位置`i`只能选择`)`，更新`p=p-1`，继续dfs
4. `p!=0 and n!=0`: 剩余`p`个左括号`(`待匹配，剩余`n`个括号对可以选择，位置`i`可以选择`(`或`)`，更新`p`和`n`的状态，继续dfs
5. 初始dfs的状态当然就是`dfs("", 0, n)`啦

简言之，对于位置`i`，有规则地进行匹配，只能选择`(`的情况——`i`位置前的括号为完全匹配；只能选择`)`的情况——只剩下`)`可以选择；`(`和`)`都能选择的情况——位置`i`前有多余的`(`，此时可以选择`)`，位置`i`后有剩余的括号对，此时可以选择`(`

### 代码

* python3

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        ans = []
        
        def dfs(s: str, p: int, n: int):
            if p == 0 and n == 0:
                ans.append(s)
            elif p == 0 and n != 0:
                dfs(s + "(", p + 1, n - 1)
            elif p != 0 and n == 0:
                dfs(s + ")", p - 1, n)
            else:
                dfs(s + "(", p + 1, n - 1)
                dfs(s + ")", p - 1, n)
        
        dfs("", 0, n)

        return ans
```

